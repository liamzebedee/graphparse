  
//     var t = d3.transition()
//       .duration(350);
  
//     function radius(d) {
//       const cradius = 18; 
//       return cradius * d.rank;
//     }
  
//     var circle;
  
//     var $nodes = g.append("g")
//       .attr("class", "nodes");
  
//     var links = g.append("g")
//       .attr("class", "links");
  
//     d3RenderData = function(nodes, edges) {
//       // Links
//       // -----
  
//       link = links
//         .selectAll("path")
//         .data(edges, (d) => `${d.source.id}${d.target.id}`)
  
//       link.exit().remove()
  
//       link
//         .enter()
//         .append("path")
//         .attr("class", "link")
//         .attr("marker-end", "url(#end)")
//         .merge(link)
  
  
//       // Node
//       // ----
  
//       node = $nodes
//         .selectAll("g")
//         .data(nodes, (d) => `${d.id}`)
      
//       node
//         .exit()
//         .remove();
  
//       node = node
//         .enter()
//         .append('g')
//         .on("mouseover", function(d){
//           graphStore.mouseoverNode(d.id)
//         })
//         .on("mouseout", function(d){
//           graphStore.mouseoutNode(d.id)
//         })
//         .on('click', function(d) {
//           graphStore.selectNode(d.id)
//         })
  
//       circle = node
//         .append("circle")
//         .attr("r", radius)
//         .attr("fill", (d) => nodeColor(d.variant))
  
//       let label = node
//         .append('text')
//         .text(function(d) { return d.label })
//         .style("font-size", function(d) {
//           let size =  Math.min(2 * radius(d), (2 * radius(d) - 8) / this.getComputedTextLength() * 16);
//           return `${size}px`; 
//         })
//         .attr("dy", ".35em")
  
//       node
//         .merge(node)
//     }
  
//     function contrastColour(r,g,b) {
//       let d = 0;
//       // Counting the perceptive luminance - human eye favors green color... 
//       let a = 1 - ( 0.299 * r + 0.587 * g + 0.114 * b)/255;
//       if (a < 0.5)
//          return "black";
//       else
//          return "white"
//     }
//     d3RenderData(nodes, edges)
  
//     mobx.autorun(() => {
//       if(graphStore.highlightedNodes == null) {
//         node
//           .attr('opacity', 1)
        
//         circle
//           .classed('selected', false)
        
//         link
//           .attr('opacity', 1)
        
//       } else {
//         node
//           .attr('opacity', 0.2)
//           .filter(function(d) {
//             return graphStore.getNodeHighlight(d.id) != null;
//           })
//           .attr('opacity', function(d) {
//             return 1 - graphStore.getNodeHighlight(d.id).score;
//           });
        
//         circle
//           .classed('selected', function(d) {
//             return _.has(graphStore.selectedNodeIds, d.id)
//           })
  
//         link
//           .attr('opacity', 0)
//       }
//     })
  
    // var zoomHandler = d3.zoom()
    //   // .scaleExtent([1, Infinity])
    //   // .translateExtent([[0, 0], [width, height]])
    //   // .extent([[0, 0], [width, height]])
    //   .on("zoom", () => {
    //     let transform = d3.event.transform;
    //     // g.attr("transform", d3.event.transform)
    //     g.style("transform", () => `translate3d(${transform.x}px, ${transform.y}px, 0px) scale(${transform.k})`)
    //   });
    
    // zoomHandler(svg);
  
  
//     var dragHandler = d3.drag()
//       .on("start", (d) => {
//         if (!d3.event.active) simulation.alphaTarget(0.3).restart();
//           d.fx = d.x;
//           d.fy = d.y;
//       })
//       .on("drag", (d) => {
//         d.fx = d3.event.x;
//         d.fy = d3.event.y;
//       })
//       .on("end", (d) => {
//         if (!d3.event.active) simulation.alphaTarget(0);
//         d.fx = null;
//         d.fy = null;
//       })
  
//     dragHandler(node);
  
//     tickActions = function() {
//       link.attr("d", function(d) {
//         // Total difference in x and y from source to target
//         let diffX = d.target.x - d.source.x;
//         let diffY = d.target.y - d.source.y;
  
//         // Length of path from center of source node to center of target node
//         let pathLength = Math.sqrt((diffX * diffX) + (diffY * diffY));
  
//         // x and y distances from center to outside edge of target node
//         let offsetX = (diffX * radius(d.target)) / pathLength;
//         let offsetY = (diffY * radius(d.target)) / pathLength;
  
//         return "M" + d.source.x + "," + d.source.y + "L" + (d.target.x - offsetX) + "," + (d.target.y - offsetY);
//       });
    
//       node
//         // .attr("style", function (d) { return `transform: translate3d(${d.x}px, ${d.y}px, 0px)` })
//         .attr('transform', (d) => `translate(${d.x} ${d.y})`)
            
//       link
//         .attr("x1", function(d) { return d.source.x; })
//         .attr("y1", function(d) { return d.source.y; })
//         .attr("x2", function(d) { return d.target.x; })
//         .attr("y2", function(d) { return d.target.y; });
//     } 
//   }


/*

function getCenter(x, y) {
    return {
        x: x / 2,
        y: y / 2
      };
}

/*
Returns a transform for center a bounding box in the browser viewport
    - W and H are the witdh and height of the window
    - w and h are the witdh and height of the bounding box
    - center cointains the coordinates of the bounding box center
    - margin defines the margin of the bounding box once zoomed
    

function to_bounding_box(center, w, h, margin) {
    const W = window.innerWidth;
    const H = window.innerHeight;
    
    var k, kh, kw, x, y;
    kw = (W - margin) / w;
    kh = (H - margin) / h;
    k = d3.min([kw, kh]);
    x = W / 2 - center.x * k;
    y = H / 2 - center.y * k;
    return d3.zoomIdentity.translate(x, y).scale(k);
};

*/